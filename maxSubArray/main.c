#include <stdio.h>


/*
题目描述：
输入一个整形数组，数组里有正数也有负数。
数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。
求所有子数组的和的最大值。要求时间复杂度为O(n)。

例如输入的数组为1, -2, 3, 10, -4, 7, 2, -5，和最大的子数组为3, 10, -4, 7, 2，
因此输出为该子数组的和18。

*/
int main()
{
	int a[] = {-1, -2, -3, -10,-7, -2, -5};
	printf("%d\n",process( a , sizeof(a)/sizeof(a[0]) ) );
	return 0;
}

/*
找最大子序列的方法很简单，只要前i项的和还没有小于0那么子序列就一直向后扩展，否则丢弃之前的子序列开始新的子序列，同时我们要记下各个子序列的和，最后找到和最大的子序列。
从头开始扫描数组
使用max存储扫描过的子数组中的最大和。
a表示扫描过的子数组最后部分的最大值

*/
int process(int array[],int n)
{
	int a = -11111;
	int  max = -111111;
	int i;
	for(i=0;i<n;i++)
	{
		if(a>0)
			a+=array[i];
		else
			a = array[i];
		if(max < a)
			max = a;

	}
	return max;
}